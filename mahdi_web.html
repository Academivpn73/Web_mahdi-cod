<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
<meta charset="UTF-8">
<title>سایت تولید فلوچارت هوشمند - نسخه پیشرفته</title>
<style>
 body { font-family: Vazirmatn, sans-serif; background:#f4f6fb; padding:20px; }
 .box { background:white; padding:20px; border-radius:12px; max-width:1100px; margin:auto; box-shadow:0 6px 20px rgba(0,0,0,0.08);} 
 textarea { width:100%; padding:12px; border-radius:10px; font-size:16px; }
 pre { padding:12px; background:#fbfbfd; border-radius:8px; white-space:pre-wrap; }
 button { background:#0b6efd; color:white; padding:10px 18px; border:none; border-radius:8px; font-size:16px; cursor:pointer; }
 #flowchartImg { margin-top:12px; width:100%; border:1px solid #ddd; border-radius:8px; }
 .legend { display:flex; gap:12px; flex-wrap:wrap; margin-top:12px; }
 .legend .item { background:#fff; border:1px solid #e3e6ef; padding:10px; border-radius:8px; min-width:220px; }
 .cols { display:grid; grid-template-columns: 1fr 1fr; gap:18px; }
 .downloadBtn { background:#28a745; color:#fff; padding:8px 12px; border-radius:8px; border:none; cursor:pointer; }
</style>
</head>
<body>
<div class="box">
  <h2>سایت تولید فلوچارت هوشمند — نسخهٔ پیشرفته</h2>
  <p>توضیح: این نسخه تشخیصِ ساختار مسئله را دقیق‌تر می‌کند، برای هر مرحله شکل مناسب انتخاب می‌کند و داخل هر شکل متنِ پیشنهادی برای قرار گرفتن در فلوچارت را می‌نویسد. همچنین یک <strong>راهنمای شکل‌ها (Legend)</strong> می‌دهد که توضیح می‌دهد هر شکل چه کاری انجام می‌دهد و چه متنی باید داخلش باشد.</p>

  <label>متن مسئله را اینجا وارد کنید:</label>
  <textarea id="problem" rows="6">در یک مسابقه ی دو میدانی ۵۰۰ نفر می‌توانند شرکت کنند ولی باید شرایط زیر را داشته باشند، سنشان از ۱۲ تا ۱۸ باشد و پس از تایید عدد سنشان را بتوان ۲برسانند ، اگر عدد بدست آمده زوج شد وارد میدان شوند

نکته: برای پیدا کردن عدد باید mod آن عدد را بر دو تقسیم کنیم و جواب صفر باشد که عدد زوج باشد</textarea>
  <div style="margin-top:10px">
    <button onclick="generate()">تولید خروجی کامل</button>
    <button class="downloadBtn" onclick="downloadImg()">دانلود تصویر</button>
  </div>

  <div class="cols" style="margin-top:18px">
    <div>
      <h3>الگوریتم (پله‌به‌پله):</h3>
      <pre id="algorithm"></pre>

      <h3>فلوچارت (متنی):</h3>
      <pre id="flowchartText"></pre>

      <h3>پایگاه داده پیشنهادی:</h3>
      <pre id="database"></pre>
    </div>

    <div>
      <h3>عکس فلوچارت رسمی:</h3>
      <img id="flowchartImg" alt="flowchart image">

      <h3>Legend — راهنمای شکل‌ها و متن داخل هر شکل</h3>
      <div class="legend" id="legend"></div>
    </div>
  </div>
</div>

<script>
// ----------------- ابزارهای کمکی -----------------
function findAgeRange(text) {
  // جستجوی الگوهای مانند "12 تا 18" یا "از 12 تا 18"
  const m = text.match(/(?:از\s*)?(\d{1,2})\s*(?:تا|\-|\–)\s*(\d{1,2})/);
  if (m) return {min: parseInt(m[1]), max: parseInt(m[2])};
  return null;
}

function findModCondition(text) {
  // جستجوی عبارت‌هایی مانند mod 2 یا مد 10 بر 2 یا "بر دو تقسیم" و "زوج"
  const modMatch = text.match(/(?:mod|مد)\s*\(?\s*(\d{1,3})\s*(?:,|بر|\/|\s)\s*(\d{1,3})\s*\)?/i);
  if (modMatch) return {a: parseInt(modMatch[1]), b: parseInt(modMatch[2])};

  if (/\bبر\s*دو\b|\bتقسیم\s*بر\s*دو\b|\bmod\s*2\b|\bزوج\b/i.test(text)) {
    return {b:2};
  }
  return null;
}

function findMaxParticipants(text) {
  const m = text.match(/(\d{2,6})\s*نفر/);
  if (m) return parseInt(m[1]);
  return null;
}

function findKeywords(text) {
  const keys = {};
  keys.age = /سن|age|سال/.test(text);
  keys.mod = /mod|مد|زوج|تقسیم|بر دو/.test(text);
  keys.range = /(تا|از).*(تا)/.test(text);
  keys.limit = /نفر|شرکت/.test(text);
  keys.verify = /تایید|بررسی/.test(text);
  return keys;
}

// ----------------- تحلیل دقیق‌تر -----------------
function analyze(problem) {
  const steps = [];
  const text = problem;

  // دریافت ورودی‌ها
  if (findKeywords(text).age) {
    steps.push({type:'input', key:'age', text:'دریافت سن شرکت‌کننده'});
  }

  // محدودیت تعداد شرکت‌کننده
  const max = findMaxParticipants(text);
  if (max) {
    steps.push({type:'process', key:'limit', text:`بررسی حداکثر تعداد شرکت‌کننده: ${max} نفر`});
  }

  // بازه سنی
  const range = findAgeRange(text);
  if (range) {
    steps.push({type:'decision', key:'ageRange', text:`آیا ${range.min} ≤ سن ≤ ${range.max} ?`});
  }

  // تشخیص عبارت مد
  const mod = findModCondition(text);
  if (mod) {
    // اگر متن می‌گوید "پس از تایید عدد سنشان را بتوان ۲برسانند" -> این یک عملیات (process) سپس تصمیم است
    if (/ضرب|×|دوبرابر|دو برابر|2برسانند|برابر\s*با\s*2/i.test(text) || /\b\d+\s*×\s*2\b/.test(text)) {
      steps.push({type:'process', key:'multiply', text:'محاسبه: سن × 2'});
    }

    // شرط زوج بودن
    steps.push({type:'decision', key:'isEven', text:(mod.b ? `آیا (نتیجه) mod ${mod.b} = 0 ؟` : 'آیا نتیجه زوج است؟')});
  }

  // نتیجه نهایی
  steps.push({type:'output', key:'result', text:'اگر همهٔ شرط‌ها درست بود → اجازه ورود'});
  steps.push({type:'end', key:'end', text:'پایان'});

  // اگر هیچ چیزی تشخیص داده نشد، حداقلی بساز
  if (steps.length === 0) {
    steps.push({type:'input', key:'input', text:'دریافت ورودی'});
    steps.push({type:'process', key:'analyze', text:'تحلیل مسئله'});
    steps.push({type:'end', key:'end', text:'پایان'});
  }

  return steps;
}

// ----------------- رسم فلوچارت با شکل‌های استاندارد -----------------
function drawFlowchart(steps) {
  const canvas = document.createElement('canvas');
  canvas.width = 1000;
  canvas.height = Math.max(420, steps.length * 140);
  const ctx = canvas.getContext('2d');
  ctx.font = '18px Vazirmatn, Arial';
  ctx.textAlign = 'center';
  ctx.lineWidth = 1.5;

  const cx = 500; // مرکز افقی
  let y = 70;

  steps.forEach((s, i) => {
    if (s.type === 'input' || s.type === 'output' || s.type === 'process') {
      const w = 520, h = 70;
      const x = cx - w/2;
      roundRect(ctx, x, y-35, w, h, 10);
      ctx.stroke();
      wrapText(ctx, s.text, cx, y+5, w-24, 20);
    } else if (s.type === 'decision') {
      const w = 420, h = 90;
      const mx = cx, my = y;
      ctx.beginPath();
      ctx.moveTo(mx, my - h/2);
      ctx.lineTo(mx + w/2, my);
      ctx.lineTo(mx, my + h/2);
      ctx.lineTo(mx - w/2, my);
      ctx.closePath();
      ctx.stroke();
      wrapText(ctx, s.text, mx, my+6, w-40, 18);
    } else if (s.type === 'end') {
      const w = 300, h = 70;
      ctx.beginPath();
      ctx.ellipse(cx, y, w/2, h/2, 0, 0, Math.PI*2);
      ctx.stroke();
      wrapText(ctx, s.text, cx, y+6, w-24, 18);
    }

    if (i < steps.length - 1) {
      drawArrow(ctx, cx, y + 45, cx, y + 95);
    }

    y += 140;
  });

  return canvas.toDataURL();
}

// ----------------- توابع کمکی Canvas -----------------
function roundRect(ctx, x, y, w, h, r) {
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.lineTo(x + w - r, y);
  ctx.quadraticCurveTo(x + w, y, x + w, y + r);
  ctx.lineTo(x + w, y + h - r);
  ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
  ctx.lineTo(x + r, y + h);
  ctx.quadraticCurveTo(x, y + h, x, y + h - r);
  ctx.lineTo(x, y + r);
  ctx.quadraticCurveTo(x, y, x + r, y);
  ctx.closePath();
}

function drawArrow(ctx, x1, y1, x2, y2) {
  ctx.beginPath();
  ctx.moveTo(x1, y1);
  ctx.lineTo(x2, y2);
  ctx.stroke();
  const angle = Math.atan2(y2 - y1, x2 - x1);
  const headlen = 8;
  ctx.beginPath();
  ctx.moveTo(x2, y2);
  ctx.lineTo(x2 - headlen * Math.cos(angle - Math.PI/6), y2 - headlen * Math.sin(angle - Math.PI/6));
  ctx.lineTo(x2 - headlen * Math.cos(angle + Math.PI/6), y2 - headlen * Math.sin(angle + Math.PI/6));
  ctx.closePath();
  ctx.fill();
}

function wrapText(ctx, text, x, y, maxWidth, lineHeight) {
  const words = text.split(/\s+/);
  let line = '';
  let curY = y - Math.floor(lineHeight/2);
  for (let n = 0; n < words.length; n++) {
    const test = line + words[n] + ' ';
    if (ctx.measureText(test).width > maxWidth && n > 0) {
      ctx.fillText(line.trim(), x, curY);
      line = words[n] + ' ';
      curY += lineHeight;
    } else {
      line = test;
    }
  }
  ctx.fillText(line.trim(), x, curY);
}

// ----------------- تولید Legend و محتوای داخل شکل‌ها -----------------
function buildLegendAndShapeGuidance(steps) {
  const legendEl = document.getElementById('legend');
  legendEl.innerHTML = '';

  const mapping = {
    input: {title:'ورودی (Input)', desc:'برای گرفتن داده از کاربر. داخل: \"دریافت ...\" مثل \"دریافت سن\"'},
    process: {title:'عملیات/پردازش (Process)', desc:'برای محاسبات یا تغییر داده‌ها. داخل: مثلا \"محاسبه: سن × 2\"'},
    decision: {title:'تصمیم/شرط (Decision)', desc:'برای شرط‌ها که اغلب جواب بله/خیر دارند. داخل: شرط به صورت سوالی مثل \"آیا 12 ≤ سن ≤ 18؟\"'},
    output: {title:'خروجی (Output)', desc:'نمایش نتیجه یا انجام عمل نهایی. داخل: \"اجازه ورود\" یا \"عدم ورود\"'},
    end: {title:'شروع/پایان (Terminator)', desc:'برای نشان دادن شروع یا پایان الگوریتم. داخل: \"شروع\" یا \"پایان\"'}
  };

  Object.keys(mapping).forEach(k => {
    const it = document.createElement('div');
    it.className = 'item';
    it.innerText = mapping[k].title + '\\n\\n' + mapping[k].desc;
    legendEl.appendChild(it);
  });

  const hint = document.createElement('div');
  hint.className = 'item';
  hint.style.gridColumn = '1 / -1';
  hint.innerHTML = '<strong>متن پیشنهادی در هر شکل برای مسئله فعلی:</strong>\\n\\n' + steps.map(s => {
    return `${s.type.toUpperCase()}: \"${s.text}\"`;
  }).join('\\n');
  legendEl.appendChild(hint);
}

// ----------------- اصلی: تولید همهٔ خروجی‌ها -----------------
function generate() {
  const problem = document.getElementById('problem').value;
  const steps = analyze(problem);

  let algo = '1. شروع\\n';
  steps.forEach((s, i) => { algo += (i+2) + '. ' + s.text + '\\n'; });
  document.getElementById('algorithm').innerText = algo;

  document.getElementById('flowchartText').innerText = steps.map(s => `[${s.text}]`).join('\\n  ↓\\n');

  const dataUrl = drawFlowchart(steps);
  document.getElementById('flowchartImg').src = dataUrl;

  document.getElementById('database').innerText = `TABLE Problems (\\n id INT PRIMARY KEY,\\n problem_text TEXT,\\n algorithm TEXT,\\n flowchart_image BLOB,\\n steps_json JSON\\n);`;

  buildLegendAndShapeGuidance(steps);
}

function downloadImg() {
  const img = document.getElementById('flowchartImg').src;
  if (!img) return alert('ابتدا فلوچارت تولید شود.');
  const a = document.createElement('a');
  a.href = img;
  a.download = 'flowchart.png';
  a.click();
}
</script>

</body>
</html>
